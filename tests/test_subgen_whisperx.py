## This is autogenerated. Inspect the code and make sure it works for you.
import os
import unittest
from unittest.mock import patch, MagicMock
from subgen_whisperx import transcribe


class TestTranscribe(unittest.TestCase):
    def setUp(self):
        self.audio_path = os.path.join("tests", "test_audio.mp3")
        self.device = "cpu"
        self.mock_model = MagicMock()
        self.mock_model.transcribe.return_value = {
            "language": "en",
            "segments": [
                {"start": 0.0, "end": 1.0, "text": "Hello"},
                {"start": 1.0, "end": 2.0, "text": "world"},
            ],
        }
        self.mock_align_model = MagicMock()
        self.mock_align_model.align.return_value = {
            "segments": [
                {"start": 0.0, "end": 1.0, "text": "Hello"},
                {"start": 1.0, "end": 2.0, "text": "world"},
            ]
        }
        # Updated metadata to include type
        self.mock_align_metadata = {
            "dictionary": {},
            "language": "en",
            "type": "wav2vec"
        }

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model")
    def test_transcribe_valid_audio(self, mock_load_align_model, mock_load_model):
        mock_load_model.return_value = self.mock_model
        mock_load_align_model.return_value = (self.mock_align_model, self.mock_align_metadata)

        language, segments = transcribe(self.audio_path, self.device)

        self.assertEqual(language, "en")
        self.assertEqual(len(segments), 2)
        self.assertEqual(segments[0]["text"], "Hello")
        self.assertEqual(segments[1]["text"], "world")

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model")
    def test_transcribe_invalid_audio_path(self, mock_load_align_model, mock_load_model):
        mock_load_model.side_effect = FileNotFoundError

        with self.assertRaises(FileNotFoundError):
            transcribe("invalid_audio.mp3", self.device)

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model")
    def test_transcribe_unsupported_device(self, mock_load_align_model, mock_load_model):
        mock_load_model.side_effect = RuntimeError("Unsupported device")

        with self.assertRaises(RuntimeError):
            transcribe(self.audio_path, "unsupported_device")

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model")
    def test_transcribe_empty_segments(self, mock_load_align_model, mock_load_model):
        self.mock_model.transcribe.return_value = {
            "language": "en",
            "segments": [],
        }
        mock_load_model.return_value = self.mock_model
        mock_load_align_model.return_value = (self.mock_align_model, self.mock_align_metadata)

        language, segments = transcribe(self.audio_path, self.device)

        self.assertEqual(language, "en")
        self.assertEqual(len(segments), 0)

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model") 
    def test_transcribe_different_language(self, mock_load_align_model, mock_load_model):
        self.mock_model.transcribe.return_value = {
            "language": "es",
            "segments": [
                {"start": 0.0, "end": 1.0, "text": "Hola"},
                {"start": 1.0, "end": 2.0, "text": "mundo"},
            ],
        }
        mock_load_model.return_value = self.mock_model
        # Updated Spanish metadata to include type
        mock_load_align_model.return_value = (
            self.mock_align_model, 
            {"dictionary": {}, "language": "es", "type": "wav2vec"}
        )

        language, segments = transcribe(self.audio_path, self.device)

        self.assertEqual(language, "es")
        self.assertEqual(len(segments), 2)
        self.assertEqual(segments[0]["text"], "Hola")
        self.assertEqual(segments[1]["text"], "mundo")

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model")
    def test_transcribe_large_audio_file(self, mock_load_align_model, mock_load_model):
        self.mock_model.transcribe.return_value = {
            "language": "en",
            "segments": [{"start": i, "end": i + 1, "text": f"Segment {i}"} for i in range(1000)],
        }
        mock_load_model.return_value = self.mock_model
        mock_load_align_model.return_value = (self.mock_align_model, self.mock_align_metadata)

        language, segments = transcribe(self.audio_path, self.device)

        self.assertEqual(language, "en")
        self.assertEqual(len(segments), 1000)
        self.assertEqual(segments[0]["text"], "Segment 0")
        self.assertEqual(segments[-1]["text"], "Segment 999")

    @patch("subgen_whisperx.whisperx.load_model")
    @patch("subgen_whisperx.whisperx.load_align_model")
    def test_transcribe_no_language_detected(self, mock_load_align_model, mock_load_model):
        self.mock_model.transcribe.return_value = {
            "language": None,
            "segments": [
                {"start": 0.0, "end": 1.0, "text": "Hello"},
                {"start": 1.0, "end": 2.0, "text": "world"},
            ],
        }
        mock_load_model.return_value = self.mock_model
        mock_load_align_model.return_value = (
            self.mock_align_model, 
            {"dictionary": {}, "language": None, "type": "wav2vec"}
        )

        language, segments = transcribe(self.audio_path, self.device)

        self.assertIsNone(language)
        self.assertEqual(len(segments), 2)
        self.assertEqual(segments[0]["text"], "Hello")
        self.assertEqual(segments[1]["text"], "world")


if __name__ == "__main__":
    unittest.main()
